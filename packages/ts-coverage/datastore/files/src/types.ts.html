
  <!DOCTYPE html>
  <html>
    <head>
      <title>types.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/types.ts</td><td class="">96.47%</td><td class="">0%</td><td class="">1160</td><td class="">1119</td><td class="">41</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import { ModelInstanceCreator } from &#x27;./datastore/datastore&#x27;;
import {
	exhaustiveCheck,
	isAWSDate,
	isAWSTime,
	isAWSDateTime,
	isAWSTimestamp,
	isAWSEmail,
	isAWSJSON,
	isAWSURL,
	isAWSPhone,
	isAWSIPAddress,
	extractPrimaryKeyFieldNames,
} from &#x27;./util&#x27;;
import { PredicateAll } from &#x27;./predicates&#x27;;
import { GRAPHQL_AUTH_MODE } from &#x27;@aws-amplify/api-graphql&#x27;;
import { Auth } from &#x27;@aws-amplify/auth&#x27;;
import { API } from &#x27;@aws-amplify/api&#x27;;
import Cache from &#x27;@aws-amplify/cache&#x27;;
import { Adapter } from &#x27;./storage/adapter&#x27;;

//#region Schema types
export type Schema = UserSchema &amp; {
	version: string;
};
export type UserSchema = {
	models: SchemaModels;
	nonModels?: SchemaNonModels;
	relationships?: RelationshipType;
	keys?: ModelKeys;
	enums: SchemaEnums;
	modelTopologicalOrdering?: Map&lt;string, string[]&gt;;
};
export type InternalSchema = {
	namespaces: SchemaNamespaces;
	version: string;
};
export type SchemaNamespaces = Record&lt;string, SchemaNamespace&gt;;
export type SchemaNamespace = UserSchema &amp; {
	name: string;
};
export type SchemaModels = Record&lt;string, SchemaModel&gt;;
export type SchemaModel = {
	name: string;
	pluralName: string;
	attributes?: ModelAttributes;
	fields: ModelFields;
	syncable?: boolean;
};

export function isSchemaModel(obj: any): obj is SchemaModel {
	return obj &amp;&amp; (&lt;SchemaModel&gt;obj).pluralName !== undefined;
}

export function isSchemaModelWithAttributes(
	m: SchemaModel | SchemaNonModel
): m is SchemaModel {
	return isSchemaModel(m) &amp;&amp; (m as SchemaModel).attributes !== undefined;
}

export type SchemaNonModels = Record&lt;string, SchemaNonModel&gt;;
export type SchemaNonModel = {
	name: string;
	fields: ModelFields;
};
type SchemaEnums = Record&lt;string, SchemaEnum&gt;;
type SchemaEnum = {
	name: string;
	values: string[];
};

export type ModelAssociation = AssociatedWith | TargetNameAssociation;
type AssociatedWith = {
	connectionType: &#x27;HAS_MANY&#x27; | &#x27;HAS_ONE&#x27;;
	associatedWith: string | string[];
	targetName?: string;
	targetNames?: string[];
};

export function isAssociatedWith(obj: any): obj is AssociatedWith {
	return obj &amp;&amp; obj.associatedWith;
}

type TargetNameAssociation = {
	connectionType: &#x27;BELONGS_TO&#x27;;
	targetName?: string;
	targetNames?: string[];
};

export function isTargetNameAssociation(
	obj: any
): obj is TargetNameAssociation {
	return obj?.targetName || obj?.targetNames;
}

export type ModelAttributes = ModelAttribute[];
export type ModelAttribute = { type: string; properties?: Record&lt;string, any&gt; };

export type ModelAuthRule = {
	allow: string;
	provider?: string;
	operations?: string[];
	ownerField?: string;
	identityClaim?: string;
	groups?: string[];
	groupClaim?: string;
	groupsField?: string;
};

export type ModelAttributeAuth = {
	type: &#x27;auth&#x27;;
	properties: {
		rules: ModelAuthRule[];
	};
};

export function isModelAttributeAuth(
	attr: ModelAttribute
): attr is ModelAttributeAuth {
	return (
		attr.type === &#x27;auth&#x27; &amp;&amp;
		attr.properties &amp;&amp;
		attr.properties.rules &amp;&amp;
		attr.properties.rules.length &gt; 0
	);
}

type ModelAttributeKey = {
	type: &#x27;key&#x27;;
	properties: {
		name?: string;
		fields: string[];
	};
};

type ModelAttributePrimaryKey = {
	type: &#x27;key&#x27;;
	properties: {
		name: never;
		fields: string[];
	};
};

type ModelAttributeCompositeKey = {
	type: &#x27;key&#x27;;
	properties: {
		name: string;
		fields: [string, string, string, string?, string?];
	};
};

export function isModelAttributeKey(
	attr: ModelAttribute
): attr is ModelAttributeKey {
	return (
		attr.type === &#x27;key&#x27; &amp;&amp;
		attr.properties &amp;&amp;
		attr.properties.fields &amp;&amp;
		attr.properties.fields.length &gt; 0
	);
}

export function isModelAttributePrimaryKey(
	attr: ModelAttribute
): attr is ModelAttributePrimaryKey {
	return isModelAttributeKey(attr) &amp;&amp; attr.properties.name === undefined;
}

export function isModelAttributeCompositeKey(
	attr: ModelAttribute
): attr is ModelAttributeCompositeKey {
	return (
		isModelAttributeKey(attr) &amp;&amp;
		attr.properties.name !== undefined &amp;&amp;
		attr.properties.fields.length &gt; 2
	);
}

export type ModelAttributeAuthProperty = {
	allow: ModelAttributeAuthAllow;
	identityClaim?: string;
	groupClaim?: string;
	groups?: string[];
	operations?: string[];
	ownerField?: string;
	provider?: ModelAttributeAuthProvider;
};

export enum ModelAttributeAuthAllow {
	CUSTOM = &#x27;custom&#x27;,
	OWNER = &#x27;owner&#x27;,
	GROUPS = &#x27;groups&#x27;,
	PRIVATE = &#x27;private&#x27;,
	PUBLIC = &#x27;public&#x27;,
}

export enum ModelAttributeAuthProvider {
	FUNCTION = &#x27;function&#x27;,
	USER_POOLS = &#x27;userPools&#x27;,
	OIDC = &#x27;oidc&#x27;,
	IAM = &#x27;iam&#x27;,
	API_KEY = &#x27;apiKey&#x27;,
}

export type ModelFields = Record&lt;string, ModelField&gt;;
export enum GraphQLScalarType {
	ID,
	String,
	Int,
	Float,
	Boolean,
	AWSDate,
	AWSTime,
	AWSDateTime,
	AWSTimestamp,
	AWSEmail,
	AWSJSON,
	AWSURL,
	AWSPhone,
	AWSIPAddress,
}

export namespace GraphQLScalarType {
	export function getJSType(
		scalar: keyof Omit&lt;
			typeof GraphQLScalarType,
			&#x27;getJSType&#x27; | &#x27;getValidationFunction&#x27;
		&gt;
	): &#x27;string&#x27; | &#x27;number&#x27; | &#x27;boolean&#x27; | &#x27;object&#x27; {
		switch (scalar) {
			case &#x27;Boolean&#x27;:
				return &#x27;boolean&#x27;;
			case &#x27;ID&#x27;:
			case &#x27;String&#x27;:
			case &#x27;AWSDate&#x27;:
			case &#x27;AWSTime&#x27;:
			case &#x27;AWSDateTime&#x27;:
			case &#x27;AWSEmail&#x27;:
			case &#x27;AWSURL&#x27;:
			case &#x27;AWSPhone&#x27;:
			case &#x27;AWSIPAddress&#x27;:
				return &#x27;string&#x27;;
			case &#x27;Int&#x27;:
			case &#x27;Float&#x27;:
			case &#x27;AWSTimestamp&#x27;:
				return &#x27;number&#x27;;
			case &#x27;AWSJSON&#x27;:
				return &#x27;object&#x27;;
			default:
				exhaustiveCheck(scalar as never);
		}
	}

	export function getValidationFunction(
		scalar: keyof Omit&lt;
			typeof GraphQLScalarType,
			&#x27;getJSType&#x27; | &#x27;getValidationFunction&#x27;
		&gt;
	): ((val: string | number) =&gt; boolean) | undefined {
		switch (scalar) {
			case &#x27;AWSDate&#x27;:
				return isAWSDate;
			case &#x27;AWSTime&#x27;:
				return isAWSTime;
			case &#x27;AWSDateTime&#x27;:
				return isAWSDateTime;
			case &#x27;AWSTimestamp&#x27;:
				return isAWSTimestamp;
			case &#x27;AWSEmail&#x27;:
				return isAWSEmail;
			case &#x27;AWSJSON&#x27;:
				return isAWSJSON;
			case &#x27;AWSURL&#x27;:
				return isAWSURL;
			case &#x27;AWSPhone&#x27;:
				return isAWSPhone;
			case &#x27;AWSIPAddress&#x27;:
				return isAWSIPAddress;
			default:
				return undefined;
		}
	}
}

export type AuthorizationRule = {
	identityClaim: string;
	ownerField: string;
	provider: &#x27;userPools&#x27; | &#x27;oidc&#x27; | &#x27;iam&#x27; | &#x27;apiKey&#x27;;
	groupClaim: string;
	groups: [string];
	authStrategy: &#x27;owner&#x27; | &#x27;groups&#x27; | &#x27;private&#x27; | &#x27;public&#x27;;
	areSubscriptionsPublic: boolean;
};

export function isGraphQLScalarType(
	obj: any
): obj is keyof Omit&lt;
	typeof GraphQLScalarType,
	&#x27;getJSType&#x27; | &#x27;getValidationFunction&#x27;
&gt; {
	return obj &amp;&amp; GraphQLScalarType[obj] !== undefined;
}

export type ModelFieldType = { model: string };
export function isModelFieldType(obj: any): obj is ModelFieldType {
	const modelField: keyof ModelFieldType = &#x27;model&#x27;;
	if (obj &amp;&amp; obj[modelField]) return true;

	return false;
}

export type NonModelFieldType = { nonModel: string };
export function isNonModelFieldType(obj: any): obj is NonModelFieldType {
	const typeField: keyof NonModelFieldType = &#x27;nonModel&#x27;;
	if (obj &amp;&amp; obj[typeField]) return true;

	return false;
}

type EnumFieldType = { enum: string };
export function isEnumFieldType(obj: any): obj is EnumFieldType {
	const modelField: keyof EnumFieldType = &#x27;enum&#x27;;
	if (obj &amp;&amp; obj[modelField]) return true;

	return false;
}

export type ModelField = {
	name: string;
	type:
		| keyof Omit&lt;
				typeof GraphQLScalarType,
				&#x27;getJSType&#x27; | &#x27;getValidationFunction&#x27;
		  &gt;
		| ModelFieldType
		| NonModelFieldType
		| EnumFieldType;
	isArray: boolean;
	isRequired?: boolean;
	isReadOnly?: boolean;
	isArrayNullable?: boolean;
	association?: ModelAssociation;
	attributes?: ModelAttributes[];
};
//#endregion

//#region Model definition
export type NonModelTypeConstructor&lt;T&gt; = {
	new (init: T): T;
};

// Class for model
export type PersistentModelConstructor&lt;T extends PersistentModel&gt; = {
	new (init: ModelInit&lt;T, PersistentModelMetaData&lt;T&gt;&gt;): T;
	copyOf(
		src: T,
		mutator: (draft: MutableModel&lt;T, PersistentModelMetaData&lt;T&gt;&gt;) =&gt; void
	): T;
};

export type TypeConstructorMap = Record&lt;
	string,
	PersistentModelConstructor&lt;any&gt; | NonModelTypeConstructor&lt;unknown&gt;
&gt;;

/**
 * Each identifier type is represented using nominal types, see:
 * https://basarat.gitbook.io/typescript/main-1/nominaltyping
 */
export declare const __identifierBrand__: unique symbol;
export type IdentifierBrand&lt;T, K&gt; = T &amp; { [__identifierBrand__]: K };

// datastore generates a uuid for you
export type ManagedIdentifier&lt;T, F extends keyof T&gt; = IdentifierBrand&lt;
	{ field: F extends string ? F : never; type: T },
	&#x27;ManagedIdentifier&#x27;
&gt;;

// you can provide a value, if not, datastore generates a uuid for you
export type OptionallyManagedIdentifier&lt;T, F extends keyof T&gt; = IdentifierBrand&lt;
	{ field: F extends string ? F : never; type: T },
	&#x27;OptionallyManagedIdentifier&#x27;
&gt;;

// You provide the values
export type CompositeIdentifier&lt;T, K extends Array&lt;keyof T&gt;&gt; = IdentifierBrand&lt;
	{ fields: K; type: T },
	&#x27;CompositeIdentifier&#x27;
&gt;;

// You provide the value
export type CustomIdentifier&lt;T, K extends keyof T&gt; = CompositeIdentifier&lt;
	T,
	[K]
&gt;;

export type Identifier&lt;T&gt; =
	| ManagedIdentifier&lt;T, any&gt;
	| OptionallyManagedIdentifier&lt;T, any&gt;
	| CompositeIdentifier&lt;T, any&gt;
	| CustomIdentifier&lt;T, any&gt;;

export type IdentifierFields&lt;
	T extends PersistentModel,
	M extends PersistentModelMetaData&lt;T&gt; = never
&gt; = (MetadataOrDefault&lt;T, M&gt;[&#x27;identifier&#x27;] extends
	| ManagedIdentifier&lt;any, any&gt;
	| OptionallyManagedIdentifier&lt;any, any&gt;
	? MetadataOrDefault&lt;T, M&gt;[&#x27;identifier&#x27;][&#x27;field&#x27;]
	: MetadataOrDefault&lt;T, M&gt;[&#x27;identifier&#x27;] extends CompositeIdentifier&lt;
			T,
			infer B
	  &gt;
	? B[number] // B[number]
	: MetadataOrDefault&lt;T, M&gt;[&#x27;identifier&#x27;][&#x27;field&#x27;]) &amp;
	string;

export type IdentifierFieldsForInit&lt;
	T extends PersistentModel,
	M extends PersistentModelMetaData&lt;T&gt;
&gt; = MetadataOrDefault&lt;T, M&gt;[&#x27;identifier&#x27;] extends
	| DefaultPersistentModelMetaData
	| ManagedIdentifier&lt;T, any&gt;
	? never
	: MetadataOrDefault&lt;T, M&gt;[&#x27;identifier&#x27;] extends OptionallyManagedIdentifier&lt;
			T,
			any
	  &gt;
	? IdentifierFields&lt;T, M&gt;
	: MetadataOrDefault&lt;T, M&gt;[&#x27;identifier&#x27;] extends CompositeIdentifier&lt;T, any&gt;
	? IdentifierFields&lt;T, M&gt;
	: never;

// Instance of model
export declare const __modelMeta__: unique symbol;

export type PersistentModelMetaData&lt;T&gt; = {
	identifier?: Identifier&lt;T&gt;;
	readOnlyFields?: string;
};

export type DefaultPersistentModelMetaData = {
	identifier: ManagedIdentifier&lt;{ id: string }, &#x27;id&#x27;&gt;;
	readOnlyFields: never;
};

export type MetadataOrDefault&lt;
	T extends PersistentModel,
	_ extends PersistentModelMetaData&lt;T&gt; = never
&gt; = T extends {
	[__modelMeta__]: PersistentModelMetaData&lt;T&gt;;
}
	? T[typeof __modelMeta__]
	: DefaultPersistentModelMetaData;

export type PersistentModel = Readonly&lt;Record&lt;string, any&gt;&gt;;

export type MetadataReadOnlyFields&lt;
	T extends PersistentModel,
	M extends PersistentModelMetaData&lt;T&gt;
&gt; = Extract&lt;
	MetadataOrDefault&lt;T, M&gt;[&#x27;readOnlyFields&#x27;] | M[&#x27;readOnlyFields&#x27;],
	keyof T
&gt;;

// This type omits the metadata field in the constructor init object
// This type omits identifier fields in the constructor init object
// This type omits readOnlyFields in the constructor init object
// This type requires some identifiers in the constructor init object (e.g. CustomIdentifier)
// This type makes optional some identifiers in the constructor init object (e.g. OptionallyManagedIdentifier)
export type ModelInit&lt;
	T extends PersistentModel,
	M extends PersistentModelMetaData&lt;T&gt; = {}
&gt; = Omit&lt;
	T,
	typeof __modelMeta__ | IdentifierFields&lt;T, M&gt; | MetadataReadOnlyFields&lt;T, M&gt;
&gt; &amp;
	(MetadataOrDefault&lt;T, M&gt;[&#x27;identifier&#x27;] extends OptionallyManagedIdentifier&lt;
		T,
		any
	&gt;
		? Partial&lt;Pick&lt;T, IdentifierFieldsForInit&lt;T, M&gt;&gt;&gt;
		: Required&lt;Pick&lt;T, IdentifierFieldsForInit&lt;T, M&gt;&gt;&gt;);

type DeepWritable&lt;T&gt; = {
	-readonly [P in keyof T]: T[P] extends TypeName&lt;T[P]&gt;
		? T[P]
		: DeepWritable&lt;T[P]&gt;;
};

export type MutableModel&lt;
	T extends PersistentModel,
	M extends PersistentModelMetaData&lt;T&gt; = {}
	// This provides Intellisense with ALL of the properties, regardless of read-only
	// but will throw a linting error if trying to overwrite a read-only property
&gt; = DeepWritable&lt;
	Omit&lt;T, IdentifierFields&lt;T, M&gt; | MetadataReadOnlyFields&lt;T, M&gt;&gt;
&gt; &amp;
	Readonly&lt;Pick&lt;T, IdentifierFields&lt;T, M&gt; | MetadataReadOnlyFields&lt;T, M&gt;&gt;&gt;;

export type ModelInstanceMetadata = {
	_version: number;
	_lastChangedAt: number;
	_deleted: boolean;
};

export type IdentifierFieldValue&lt;
	T extends PersistentModel,
	M extends PersistentModelMetaData&lt;T&gt;
&gt; = MetadataOrDefault&lt;T, M&gt;[&#x27;identifier&#x27;] extends CompositeIdentifier&lt;T, any&gt;
	? MetadataOrDefault&lt;T, M&gt;[&#x27;identifier&#x27;][&#x27;fields&#x27;] extends [any]
		? T[MetadataOrDefault&lt;T, M&gt;[&#x27;identifier&#x27;][&#x27;fields&#x27;][0]]
		: never
	: T[MetadataOrDefault&lt;T, M&gt;[&#x27;identifier&#x27;][&#x27;field&#x27;]];

export type IdentifierFieldOrIdentifierObject&lt;
	T extends PersistentModel,
	M extends PersistentModelMetaData&lt;T&gt;
&gt; = Pick&lt;T, IdentifierFields&lt;T, M&gt;&gt; | IdentifierFieldValue&lt;T, M&gt;;

export function isIdentifierObject&lt;T extends PersistentModel&gt;(
	obj: any,
	modelDefinition: SchemaModel
): obj is IdentifierFields&lt;T extends PersistentModel ? T : never, any&gt; {
	const keys = extractPrimaryKeyFieldNames(modelDefinition);

	return (
		typeof obj === &#x27;object&#x27; &amp;&amp; obj &amp;&amp; keys.every(k =&gt; obj[k] !== undefined)
	);
}
//#endregion

//#region Subscription messages
export enum OpType {
	INSERT = &#x27;INSERT&#x27;,
	UPDATE = &#x27;UPDATE&#x27;,
	DELETE = &#x27;DELETE&#x27;,
}

export type SubscriptionMessage&lt;T extends PersistentModel&gt; = Pick&lt;
	InternalSubscriptionMessage&lt;T&gt;,
	&#x27;opType&#x27; | &#x27;element&#x27; | &#x27;model&#x27; | &#x27;condition&#x27;
&gt;;

export type InternalSubscriptionMessage&lt;T extends PersistentModel&gt; = {
	opType: OpType;
	element: T;
	model: PersistentModelConstructor&lt;T&gt;;
	condition: PredicatesGroup&lt;T&gt; | null;
	savedElement?: T;
};

export type DataStoreSnapshot&lt;T extends PersistentModel&gt; = {
	items: T[];
	isSynced: boolean;
};
//#endregion

//#region Predicates

export type PredicateExpression&lt;
	M extends PersistentModel,
	FT
&gt; = TypeName&lt;FT&gt; extends keyof MapTypeToOperands&lt;FT&gt;
	? (
			operator: keyof MapTypeToOperands&lt;FT&gt;[TypeName&lt;FT&gt;],
			// make the operand type match the type they&#x27;re trying to filter on
			operand: MapTypeToOperands&lt;FT&gt;[TypeName&lt;FT&gt;][keyof MapTypeToOperands&lt;FT&gt;[TypeName&lt;FT&gt;]]
	  ) =&gt; ModelPredicate&lt;M&gt;
	: never;

type EqualityOperators&lt;T&gt; = {
	ne: T;
	eq: T;
};
type ScalarNumberOperators&lt;T&gt; = EqualityOperators&lt;T&gt; &amp; {
	le: T;
	lt: T;
	ge: T;
	gt: T;
};
type NumberOperators&lt;T&gt; = ScalarNumberOperators&lt;T&gt; &amp; {
	between: [T, T];
};
type StringOperators&lt;T&gt; = ScalarNumberOperators&lt;T&gt; &amp; {
	beginsWith: T;
	contains: T;
	notContains: T;
};
type BooleanOperators&lt;T&gt; = EqualityOperators&lt;T&gt;;
type ArrayOperators&lt;T&gt; = {
	contains: T;
	notContains: T;
};
export type AllOperators = NumberOperators&lt;any&gt; &amp;
	StringOperators&lt;any&gt; &amp;
	ArrayOperators&lt;any&gt;;

type MapTypeToOperands&lt;T&gt; = {
	number: NumberOperators&lt;NonNullable&lt;T&gt;&gt;;
	string: StringOperators&lt;NonNullable&lt;T&gt;&gt;;
	boolean: BooleanOperators&lt;NonNullable&lt;T&gt;&gt;;
	&#x27;number[]&#x27;: ArrayOperators&lt;number&gt;;
	&#x27;string[]&#x27;: ArrayOperators&lt;string&gt;;
	&#x27;boolean[]&#x27;: ArrayOperators&lt;boolean&gt;;
};

type TypeName&lt;T&gt; = T extends string
	? &#x27;string&#x27;
	: T extends number
	? &#x27;number&#x27;
	: T extends boolean
	? &#x27;boolean&#x27;
	: T extends string[]
	? &#x27;string[]&#x27;
	: T extends number[]
	? &#x27;number[]&#x27;
	: T extends boolean[]
	? &#x27;boolean[]&#x27;
	: never;

export type PredicateGroups&lt;T extends PersistentModel&gt; = {
	and: (
		predicate: (predicate: ModelPredicate&lt;T&gt;) =&gt; ModelPredicate&lt;T&gt;
	) =&gt; ModelPredicate&lt;T&gt;;
	or: (
		predicate: (predicate: ModelPredicate&lt;T&gt;) =&gt; ModelPredicate&lt;T&gt;
	) =&gt; ModelPredicate&lt;T&gt;;
	not: (
		predicate: (predicate: ModelPredicate&lt;T&gt;) =&gt; ModelPredicate&lt;T&gt;
	) =&gt; ModelPredicate&lt;T&gt;;
};

export type ModelPredicate&lt;M extends PersistentModel&gt; = {
	[K in keyof M]-?: PredicateExpression&lt;M, NonNullable&lt;M[K]&gt;&gt;;
} &amp; PredicateGroups&lt;M&gt;;

export type ProducerModelPredicate&lt;M extends PersistentModel&gt; = (
	condition: ModelPredicate&lt;M&gt;
) =&gt; ModelPredicate&lt;M&gt;;

export type PredicatesGroup&lt;T extends PersistentModel&gt; = {
	type: keyof PredicateGroups&lt;T&gt;;
	predicates: (PredicateObject&lt;T&gt; | PredicatesGroup&lt;T&gt;)[];
};

export function isPredicateObj&lt;T extends PersistentModel&gt;(
	obj: any
): obj is PredicateObject&lt;T&gt; {
	return obj &amp;&amp; (&lt;PredicateObject&lt;T&gt;&gt;obj).field !== undefined;
}

export function isPredicateGroup&lt;T extends PersistentModel&gt;(
	obj: any
): obj is PredicatesGroup&lt;T&gt; {
	return obj &amp;&amp; (&lt;PredicatesGroup&lt;T&gt;&gt;obj).type !== undefined;
}

export type PredicateObject&lt;T extends PersistentModel&gt; = {
	field: keyof T;
	operator: keyof AllOperators;
	operand: any;
};

export enum QueryOne {
	FIRST,
	LAST,
}
export type GraphQLField = {
	[field: string]: {
		[operator: string]: string | number | [number, number];
	};
};

export type GraphQLCondition = Partial&lt;
	| GraphQLField
	| {
			and: [GraphQLCondition];
			or: [GraphQLCondition];
			not: GraphQLCondition;
	  }
&gt;;

export type GraphQLFilter = Partial&lt;
	| GraphQLField
	| {
			and: GraphQLFilter[];
	  }
	| {
			or: GraphQLFilter[];
	  }
	| {
			not: GraphQLFilter;
	  }
&gt;;

//#endregion

//#region Pagination

export type ProducerPaginationInput&lt;T extends PersistentModel&gt; = {
	sort?: ProducerSortPredicate&lt;T&gt;;
	limit?: number;
	page?: number;
};

export type ObserveQueryOptions&lt;T extends PersistentModel&gt; = Pick&lt;
	ProducerPaginationInput&lt;T&gt;,
	&#x27;sort&#x27;
&gt;;

export type PaginationInput&lt;T extends PersistentModel&gt; = {
	sort?: SortPredicate&lt;T&gt;;
	limit?: number;
	page?: number;
};

export type ProducerSortPredicate&lt;M extends PersistentModel&gt; = (
	condition: SortPredicate&lt;M&gt;
) =&gt; SortPredicate&lt;M&gt;;

export type SortPredicate&lt;T extends PersistentModel&gt; = {
	[K in keyof T]-?: SortPredicateExpression&lt;T, NonNullable&lt;T[K]&gt;&gt;;
};

export type SortPredicateExpression&lt;
	M extends PersistentModel,
	FT
&gt; = TypeName&lt;FT&gt; extends keyof MapTypeToOperands&lt;FT&gt;
	? (sortDirection: keyof typeof SortDirection) =&gt; SortPredicate&lt;M&gt;
	: never;

export enum SortDirection {
	ASCENDING = &#x27;ASCENDING&#x27;,
	DESCENDING = &#x27;DESCENDING&#x27;,
}

export type SortPredicatesGroup&lt;T extends PersistentModel&gt; =
	SortPredicateObject&lt;T&gt;[];

export type SortPredicateObject&lt;T extends PersistentModel&gt; = {
	field: keyof T;
	sortDirection: keyof typeof SortDirection;
};

//#endregion

//#region System Components

export type SystemComponent = {
	setUp(
		schema: InternalSchema,
		namespaceResolver: NamespaceResolver,
		modelInstanceCreator: ModelInstanceCreator,
		getModelConstructorByModelName: (
			namsespaceName: string,
			modelName: string
		) =&gt; PersistentModelConstructor&lt;any&gt;,
		appId: string
	): Promise&lt;void&gt;;
};

export type NamespaceResolver = (
	modelConstructor: PersistentModelConstructor&lt;any&gt;
) =&gt; string;

export type ControlMessageType&lt;T&gt; = {
	type: T;
	data?: any;
};

//#endregion

//#region Relationship types
export type RelationType = {
	fieldName: string;
	modelName: string;
	relationType: &#x27;HAS_ONE&#x27; | &#x27;HAS_MANY&#x27; | &#x27;BELONGS_TO&#x27;;
	targetName?: string;
	targetNames?: string[];
	associatedWith?: string | string[];
};

type IndexOptions = {
	unique?: boolean;
};

export type IndexesType = Array&lt;[string, string[], IndexOptions?]&gt;;

export type RelationshipType = {
	[modelName: string]: {
		indexes: IndexesType;
		relationTypes: RelationType[];
	};
};

//#endregion

//#region Key type
export type KeyType = {
	primaryKey?: string[];
	compositeKeys?: Set&lt;string&gt;[];
};

export type ModelKeys = {
	[modelName: string]: KeyType;
};

//#endregion

//#region DataStore config types
export type DataStoreConfig = {
	DataStore?: {
		authModeStrategyType?: AuthModeStrategyType;
		conflictHandler?: ConflictHandler; // default : retry until client wins up to x times
		errorHandler?: (error: SyncError&lt;PersistentModel&gt;) =&gt; void; // default : logger.warn
		maxRecordsToSync?: number; // merge
		syncPageSize?: number;
		fullSyncInterval?: number;
		syncExpressions?: SyncExpression[];
		authProviders?: AuthProviders;
		storageAdapter?: Adapter;
	};
	authModeStrategyType?: AuthModeStrategyType;
	conflictHandler?: ConflictHandler; // default : retry until client wins up to x times
	errorHandler?: (error: SyncError&lt;PersistentModel&gt;) =&gt; void; // default : logger.warn
	maxRecordsToSync?: number; // merge
	syncPageSize?: number;
	fullSyncInterval?: number;
	syncExpressions?: SyncExpression[];
	authProviders?: AuthProviders;
	storageAdapter?: Adapter;
};

export type AuthProviders = {
	functionAuthProvider: () =&gt; { token: string } | Promise&lt;{ token: string }&gt;;
};

export enum AuthModeStrategyType {
	DEFAULT = &#x27;DEFAULT&#x27;,
	MULTI_AUTH = &#x27;MULTI_AUTH&#x27;,
}

export type AuthModeStrategyReturn =
	| GRAPHQL_AUTH_MODE
	| GRAPHQL_AUTH_MODE[]
	| undefined
	| null;

export type AuthModeStrategyParams = {
	schema: InternalSchema;
	modelName: string;
	operation: ModelOperation;
};

export type AuthModeStrategy = (
	authModeStrategyParams: AuthModeStrategyParams
) =&gt; AuthModeStrategyReturn | Promise&lt;AuthModeStrategyReturn&gt;;

export enum ModelOperation {
	CREATE = &#x27;CREATE&#x27;,
	READ = &#x27;READ&#x27;,
	UPDATE = &#x27;UPDATE&#x27;,
	DELETE = &#x27;DELETE&#x27;,
}

export type ModelAuthModes = Record&lt;
	string,
	{
		[Property in ModelOperation]: GRAPHQL_AUTH_MODE[];
	}
&gt;;

export type SyncExpression = Promise&lt;{
	modelConstructor: any;
	conditionProducer: (c?: any) =&gt; any;
}&gt;;

/*
Adds Intellisense when passing a function | promise that returns a predicate
Or just a predicate. E.g.,

syncExpressions: [
	syncExpression(Post, c =&gt; c.rating(&#x27;gt&#x27;, 5)),

	OR

	syncExpression(Post, async () =&gt; {
		return c =&gt; c.rating(&#x27;gt&#x27;, 5)
	}),
]
*/
type Option0 = [];
type Option1&lt;T extends PersistentModel&gt; = [ModelPredicate&lt;T&gt; | undefined];
type Option&lt;T extends PersistentModel&gt; = Option0 | Option1&lt;T&gt;;

type Lookup&lt;T extends PersistentModel&gt; = {
	0:
		| ProducerModelPredicate&lt;T&gt;
		| Promise&lt;ProducerModelPredicate&lt;T&gt;&gt;
		| typeof PredicateAll;
	1: ModelPredicate&lt;T&gt; | undefined;
};

type ConditionProducer&lt;T extends PersistentModel, A extends Option&lt;T&gt;&gt; = (
	...args: A
) =&gt; A[&#x27;length&#x27;] extends keyof Lookup&lt;T&gt; ? Lookup&lt;T&gt;[A[&#x27;length&#x27;]] : never;

export async function syncExpression&lt;
	T extends PersistentModel,
	A extends Option&lt;T&gt;
&gt;(
	modelConstructor: PersistentModelConstructor&lt;T&gt;,
	conditionProducer: ConditionProducer&lt;T, A&gt;
): Promise&lt;{
	modelConstructor: PersistentModelConstructor&lt;T&gt;;
	conditionProducer: ConditionProducer&lt;T, A&gt;;
}&gt; {
	return {
		modelConstructor,
		conditionProducer,
	};
}

export type SyncConflict = {
	modelConstructor: PersistentModelConstructor&lt;any&gt;;
	localModel: PersistentModel;
	remoteModel: PersistentModel;
	operation: OpType;
	attempts: number;
};

export type SyncError&lt;T extends PersistentModel&gt; = {
	message: string;
	errorType: ErrorType;
	errorInfo?: string;
	recoverySuggestion?: string;
	model?: string;
	localModel: T;
	remoteModel: T;
	process: ProcessName;
	operation: string;
	cause?: Error;
};

export type ErrorType =
	| &#x27;ConfigError&#x27;
	| &#x27;BadModel&#x27;
	| &#x27;BadRecord&#x27;
	| &#x27;Unauthorized&#x27;
	| &#x27;Transient&#x27;
	| &#x27;Unknown&#x27;;

export enum ProcessName {
	&#x27;sync&#x27; = &#x27;sync&#x27;,
	&#x27;mutate&#x27; = &#x27;mutate&#x27;,
	&#x27;subscribe&#x27; = &#x27;subscribe&#x27;,
}

export const DISCARD = Symbol(&#x27;DISCARD&#x27;);

export type ConflictHandler = (
	conflict: SyncConflict
) =&gt;
	| Promise&lt;PersistentModel | typeof DISCARD&gt;
	| PersistentModel
	| typeof DISCARD;
export type ErrorHandler = (error: SyncError&lt;PersistentModel&gt;) =&gt; void;

export type DeferredCallbackResolverOptions = {
	callback: () =&gt; void;
	maxInterval?: number;
	errorHandler?: (error: string) =&gt; void;
};

export enum LimitTimerRaceResolvedValues {
	LIMIT = &#x27;LIMIT&#x27;,
	TIMER = &#x27;TIMER&#x27;,
}
//#endregion

export type AmplifyContext = {
	Auth: typeof Auth;
	API: typeof API;
	Cache: typeof Cache;
};
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:50,&quot;character&quot;:30,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:51,&quot;character&quot;:8,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:79,&quot;character&quot;:33,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:80,&quot;character&quot;:8,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:80,&quot;character&quot;:15,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:80,&quot;character&quot;:19,&quot;text&quot;:&quot;associatedWith&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:90,&quot;character&quot;:1,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:92,&quot;character&quot;:8,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:92,&quot;character&quot;:13,&quot;text&quot;:&quot;targetName&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:92,&quot;character&quot;:27,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:92,&quot;character&quot;:32,&quot;text&quot;:&quot;targetNames&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:122,&quot;character&quot;:18,&quot;text&quot;:&quot;rules&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:123,&quot;character&quot;:18,&quot;text&quot;:&quot;rules&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:123,&quot;character&quot;:24,&quot;text&quot;:&quot;length&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:157,&quot;character&quot;:18,&quot;text&quot;:&quot;fields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:158,&quot;character&quot;:18,&quot;text&quot;:&quot;fields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:158,&quot;character&quot;:25,&quot;text&quot;:&quot;length&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:295,&quot;character&quot;:1,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:300,&quot;character&quot;:8,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:300,&quot;character&quot;:33,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:304,&quot;character&quot;:33,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:306,&quot;character&quot;:5,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:306,&quot;character&quot;:12,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:312,&quot;character&quot;:36,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:314,&quot;character&quot;:5,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:314,&quot;character&quot;:12,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:320,&quot;character&quot;:32,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:322,&quot;character&quot;:5,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:322,&quot;character&quot;:12,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:521,&quot;character&quot;:1,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:527,&quot;character&quot;:9,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:527,&quot;character&quot;:29,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:527,&quot;character&quot;:52,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:647,&quot;character&quot;:1,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:649,&quot;character&quot;:8,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:653,&quot;character&quot;:1,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:655,&quot;character&quot;:8,&quot;text&quot;:&quot;obj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:661,&quot;character&quot;:1,&quot;text&quot;:&quot;operand&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:768,&quot;character&quot;:1,&quot;text&quot;:&quot;data&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:874,&quot;character&quot;:1,&quot;text&quot;:&quot;modelConstructor&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/types.ts&quot;,&quot;line&quot;:875,&quot;character&quot;:21,&quot;text&quot;:&quot;c&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Mon, 17 Oct 2022 20:15:29 GMT</p>
    </body>
  </html>
  