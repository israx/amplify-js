
  <!DOCTYPE html>
  <html>
    <head>
      <title>AWSS3Provider.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/providers/AWSS3Provider.ts</td><td class="">96.20%</td><td class="">0%</td><td class="">1080</td><td class="">1039</td><td class="">41</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">/*
 * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
import {
	ConsoleLogger as Logger,
	Credentials,
	Parser,
	ICredentials,
	StorageHelper,
	Hub,
} from &#x27;@aws-amplify/core&#x27;;
import {
	S3Client,
	GetObjectCommand,
	DeleteObjectCommand,
	ListObjectsV2Command,
	GetObjectCommandOutput,
	DeleteObjectCommandInput,
	CopyObjectCommandInput,
	CopyObjectCommand,
	PutObjectCommandInput,
	GetObjectCommandInput,
	ListObjectsV2Request,
} from &#x27;@aws-sdk/client-s3&#x27;;
import { formatUrl } from &#x27;@aws-sdk/util-format-url&#x27;;
import { createRequest } from &#x27;@aws-sdk/util-create-request&#x27;;
import { S3RequestPresigner } from &#x27;@aws-sdk/s3-request-presigner&#x27;;
import {
	SEND_DOWNLOAD_PROGRESS_EVENT,
	SEND_UPLOAD_PROGRESS_EVENT,
} from &#x27;./axios-http-handler&#x27;;
import {
	StorageOptions,
	StorageProvider,
	S3ProviderGetConfig,
	S3ProviderGetOuput,
	S3ProviderPutConfig,
	S3ProviderRemoveConfig,
	S3ProviderListOutput,
	S3ProviderListConfig,
	S3ProviderCopyConfig,
	S3ProviderCopyOutput,
	S3CopySource,
	S3CopyDestination,
	StorageAccessLevel,
	CustomPrefix,
	S3ProviderRemoveOutput,
	S3ProviderPutOutput,
	ResumableUploadConfig,
	UploadTask,
	S3ClientOptions,
} from &#x27;../types&#x27;;
import { StorageErrorStrings } from &#x27;../common/StorageErrorStrings&#x27;;
import { dispatchStorageEvent } from &#x27;../common/StorageUtils&#x27;;
import {
	createPrefixMiddleware,
	prefixMiddlewareOptions,
	getPrefix,
	autoAdjustClockskewMiddleware,
	autoAdjustClockskewMiddlewareOptions,
	createS3Client,
} from &#x27;../common/S3ClientUtils&#x27;;
import { S3ProviderListOutputWithToken } from &#x27;.././types/AWSS3Provider&#x27;;
import { AWSS3ProviderManagedUpload } from &#x27;./AWSS3ProviderManagedUpload&#x27;;
import { AWSS3UploadTask, TaskEvents } from &#x27;./AWSS3UploadTask&#x27;;
import { UPLOADS_STORAGE_KEY } from &#x27;../common/StorageConstants&#x27;;
import * as events from &#x27;events&#x27;;
import { CancelTokenSource } from &#x27;axios&#x27;;

const logger = new Logger(&#x27;AWSS3Provider&#x27;);

const DEFAULT_STORAGE_LEVEL = &#x27;public&#x27;;
const DEFAULT_PRESIGN_EXPIRATION = 900;

interface AddTaskInput {
	accessLevel: StorageAccessLevel;
	file: Blob;
	bucket: string;
	emitter: events.EventEmitter;
	key: string;
	s3Client: S3Client;
	params?: PutObjectCommandInput;
}

/**
 * Provide storage methods to use AWS S3
 */
export class AWSS3Provider implements StorageProvider {
	static readonly CATEGORY = &#x27;Storage&#x27;;
	static readonly PROVIDER_NAME = &#x27;AWSS3&#x27;;
	private _config: StorageOptions;
	private _storage: Storage;

	/**
	 * Initialize Storage with AWS configurations
	 * @param {Object} config - Configuration object for storage
	 */
	constructor(config?: StorageOptions) {
		this._config = config ? config : {};
		this._storage = new StorageHelper().getStorage();
		Hub.listen(&#x27;auth&#x27;, data =&gt; {
			const { payload } = data;
			if (payload.event === &#x27;signOut&#x27; || payload.event === &#x27;signIn&#x27;) {
				this._storage.removeItem(UPLOADS_STORAGE_KEY);
			}
		});
		logger.debug(&#x27;Storage Options&#x27;, this._config);
	}

	/**
	 * get the category of the plugin
	 */
	public getCategory(): string {
		return AWSS3Provider.CATEGORY;
	}

	/**
	 * get provider name of the plugin
	 */
	getProviderName(): &#x27;AWSS3&#x27; {
		return AWSS3Provider.PROVIDER_NAME;
	}

	/**
	 * Configure Storage part with aws configuration
	 * @param {Object} config - Configuration of the Storage
	 * @return {Object} - Current configuration
	 */
	public configure(config?): object {
		logger.debug(&#x27;configure Storage&#x27;, config);
		if (!config) return this._config;
		const amplifyConfig = Parser.parseMobilehubConfig(config);
		this._config = Object.assign({}, this._config, amplifyConfig.Storage);
		if (!this._config.bucket) {
			logger.debug(&#x27;Do not have bucket yet&#x27;);
		}
		return this._config;
	}

	private startResumableUpload(
		addTaskInput: AddTaskInput,
		config: S3ProviderPutConfig &amp; ResumableUploadConfig
	): UploadTask {
		const { s3Client, emitter, key, file, params } = addTaskInput;
		const {
			progressCallback,
			completeCallback,
			errorCallback,
			track = false,
		} = config;
		if (!(file instanceof Blob)) {
			throw new Error(StorageErrorStrings.INVALID_BLOB);
		}

		emitter.on(TaskEvents.UPLOAD_PROGRESS, event =&gt; {
			if (progressCallback) {
				if (typeof progressCallback === &#x27;function&#x27;) {
					progressCallback(event);
				} else {
					logger.warn(
						&#x27;progressCallback should be a function, not a &#x27; +
							typeof progressCallback
					);
				}
			}
		});

		emitter.on(TaskEvents.UPLOAD_COMPLETE, event =&gt; {
			if (completeCallback) {
				if (typeof completeCallback === &#x27;function&#x27;) {
					completeCallback(event);
				} else {
					logger.warn(
						&#x27;completeCallback should be a function, not a &#x27; +
							typeof completeCallback
					);
				}
			}
		});

		emitter.on(TaskEvents.ERROR, err =&gt; {
			if (errorCallback) {
				if (typeof errorCallback === &#x27;function&#x27;) {
					errorCallback(err);
				} else {
					logger.warn(
						&#x27;errorCallback should be a function, not a &#x27; + typeof errorCallback
					);
				}
			}
		});

		// we want to keep this function sync so we defer this promise to AWSS3UploadTask to resolve when it&#x27;s needed
		// when its doing a final check with _listSingleFile function
		const prefixPromise: Promise&lt;string&gt; = Credentials.get().then(
			(credentials: any) =&gt; {
				const cred = Credentials.shear(credentials);
				return getPrefix({
					...config,
					credentials: cred,
				});
			}
		);

		const task = new AWSS3UploadTask({
			s3Client,
			file,
			emitter,
			level: config.level,
			storage: this._storage,
			params,
			prefixPromise,
		});

		dispatchStorageEvent(
			track,
			&#x27;upload&#x27;,
			{ method: &#x27;put&#x27;, result: &#x27;success&#x27; },
			null,
			`Upload Task created successfully for ${key}`
		);

		// automatically start the upload task
		task.resume();

		return task;
	}

	/**
	 * Copy an object from a source object to a new object within the same bucket. Can optionally copy files across
	 * different level or identityId (if source object&#x27;s level is &#x27;protected&#x27;).
	 *
	 * @async
	 * @param {S3CopySource} src - Key and optionally access level and identityId of the source object.
	 * @param {S3CopyDestination} dest - Key and optionally access level of the destination object.
	 * @param {S3ProviderCopyConfig} [config] - Optional configuration for s3 commands.
	 * @return {Promise&lt;S3ProviderCopyOutput&gt;} The key of the copied object.
	 */
	public async copy(
		src: S3CopySource,
		dest: S3CopyDestination,
		config?: S3ProviderCopyConfig
	): Promise&lt;S3ProviderCopyOutput&gt; {
		const credentialsOK = await this._ensureCredentials();
		if (!credentialsOK || !this._isWithCredentials(this._config)) {
			throw new Error(StorageErrorStrings.NO_CREDENTIALS);
		}
		const opt = Object.assign({}, this._config, config);
		const {
			acl,
			bucket,
			cacheControl,
			expires,
			track,
			serverSideEncryption,
			SSECustomerAlgorithm,
			SSECustomerKey,
			SSECustomerKeyMD5,
			SSEKMSKeyId,
		} = opt;
		const {
			level: srcLevel = DEFAULT_STORAGE_LEVEL,
			identityId: srcIdentityId,
			key: srcKey,
		} = src;
		const { level: destLevel = DEFAULT_STORAGE_LEVEL, key: destKey } = dest;
		if (!srcKey || typeof srcKey !== &#x27;string&#x27;) {
			throw new Error(StorageErrorStrings.NO_SRC_KEY);
		}
		if (!destKey || typeof destKey !== &#x27;string&#x27;) {
			throw new Error(StorageErrorStrings.NO_DEST_KEY);
		}
		if (srcLevel !== &#x27;protected&#x27; &amp;&amp; srcIdentityId) {
			logger.warn(
				`You may copy files from another user if the source level is &quot;protected&quot;, currently it&#x27;s ${srcLevel}`
			);
		}
		const srcPrefix = this._prefix({
			...opt,
			level: srcLevel,
			...(srcIdentityId &amp;&amp; { identityId: srcIdentityId }),
		});
		const destPrefix = this._prefix({ ...opt, level: destLevel });
		const finalSrcKey = `${bucket}/${srcPrefix}${srcKey}`;
		const finalDestKey = `${destPrefix}${destKey}`;
		logger.debug(`copying ${finalSrcKey} to ${finalDestKey}`);

		const params: CopyObjectCommandInput = {
			Bucket: bucket,
			CopySource: finalSrcKey,
			Key: finalDestKey,
			// Copies over metadata like contentType as well
			MetadataDirective: &#x27;COPY&#x27;,
		};

		if (cacheControl) params.CacheControl = cacheControl;
		if (expires) params.Expires = expires;
		if (serverSideEncryption) {
			params.ServerSideEncryption = serverSideEncryption;
		}
		if (SSECustomerAlgorithm) {
			params.SSECustomerAlgorithm = SSECustomerAlgorithm;
		}
		if (SSECustomerKey) {
			params.SSECustomerKey = SSECustomerKey;
		}
		if (SSECustomerKeyMD5) {
			params.SSECustomerKeyMD5 = SSECustomerKeyMD5;
		}
		if (SSEKMSKeyId) {
			params.SSEKMSKeyId = SSEKMSKeyId;
		}
		if (acl) params.ACL = acl;

		const s3 = this._createNewS3Client(opt);
		try {
			await s3.send(new CopyObjectCommand(params));
			dispatchStorageEvent(
				track,
				&#x27;copy&#x27;,
				{
					method: &#x27;copy&#x27;,
					result: &#x27;success&#x27;,
				},
				null,
				`Copy success from ${srcKey} to ${destKey}`
			);
			return {
				key: destKey,
			};
		} catch (error) {
			dispatchStorageEvent(
				track,
				&#x27;copy&#x27;,
				{
					method: &#x27;copy&#x27;,
					result: &#x27;failed&#x27;,
				},
				null,
				`Copy failed from ${srcKey} to ${destKey}`
			);
			throw error;
		}
	}

	/**
	 * Get a presigned URL of the file or the object data when download:true
	 *
	 * @param {string} key - key of the object
	 * @param {S3ProviderGetConfig} [config] - Optional configuration for the underlying S3 command
	 * @return {Promise&lt;string | GetObjectCommandOutput&gt;} - A promise resolves to Amazon S3 presigned URL or the
	 * GetObjectCommandOutput if download is set to true on success
	 */
	public async get&lt;T extends S3ProviderGetConfig &amp; StorageOptions&gt;(
		key: string,
		config?: T
	): Promise&lt;S3ProviderGetOuput&lt;T&gt;&gt;;
	public async get(
		key: string,
		config?: S3ProviderGetConfig
	): Promise&lt;string | GetObjectCommandOutput&gt; {
		const credentialsOK = await this._ensureCredentials();
		if (!credentialsOK || !this._isWithCredentials(this._config)) {
			throw new Error(StorageErrorStrings.NO_CREDENTIALS);
		}
		const opt = Object.assign({}, this._config, config);
		const {
			bucket,
			download,
			cacheControl,
			contentDisposition,
			contentEncoding,
			contentLanguage,
			contentType,
			expires,
			track,
			SSECustomerAlgorithm,
			SSECustomerKey,
			SSECustomerKeyMD5,
			progressCallback,
		} = opt;
		const prefix = this._prefix(opt);
		const final_key = prefix + key;
		const emitter = new events.EventEmitter();
		const s3 = this._createNewS3Client(opt, emitter);
		logger.debug(&#x27;get &#x27; + key + &#x27; from &#x27; + final_key);

		const params: GetObjectCommandInput = {
			Bucket: bucket,
			Key: final_key,
		};

		// See: https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#getObject-property
		if (cacheControl) params.ResponseCacheControl = cacheControl;
		if (contentDisposition)
			params.ResponseContentDisposition = contentDisposition;
		if (contentEncoding) params.ResponseContentEncoding = contentEncoding;
		if (contentLanguage) params.ResponseContentLanguage = contentLanguage;
		if (contentType) params.ResponseContentType = contentType;
		if (SSECustomerAlgorithm) {
			params.SSECustomerAlgorithm = SSECustomerAlgorithm;
		}
		if (SSECustomerKey) {
			params.SSECustomerKey = SSECustomerKey;
		}
		if (SSECustomerKeyMD5) {
			params.SSECustomerKeyMD5 = SSECustomerKeyMD5;
		}

		if (download === true) {
			const getObjectCommand = new GetObjectCommand(params);
			try {
				if (progressCallback) {
					if (typeof progressCallback === &#x27;function&#x27;) {
						emitter.on(SEND_DOWNLOAD_PROGRESS_EVENT, progress =&gt; {
							progressCallback(progress);
						});
					} else {
						logger.warn(
							&#x27;progressCallback should be a function, not a &#x27; +
								typeof progressCallback
						);
					}
				}
				const response = await s3.send(getObjectCommand);
				emitter.removeAllListeners(SEND_DOWNLOAD_PROGRESS_EVENT);
				dispatchStorageEvent(
					track,
					&#x27;download&#x27;,
					{ method: &#x27;get&#x27;, result: &#x27;success&#x27; },
					{
						fileSize: Number(response.Body[&#x27;size&#x27;] || response.Body[&#x27;length&#x27;]),
					},
					`Download success for ${key}`
				);
				return response;
			} catch (error) {
				dispatchStorageEvent(
					track,
					&#x27;download&#x27;,
					{
						method: &#x27;get&#x27;,
						result: &#x27;failed&#x27;,
					},
					null,
					`Download failed with ${error.message}`
				);
				throw error;
			}
		}

		try {
			const signer = new S3RequestPresigner({ ...s3.config });
			const request = await createRequest(s3, new GetObjectCommand(params));
			// Default is 15 mins as defined in V2 AWS SDK
			const url = formatUrl(
				await signer.presign(request, {
					expiresIn: expires || DEFAULT_PRESIGN_EXPIRATION,
				})
			);
			dispatchStorageEvent(
				track,
				&#x27;getSignedUrl&#x27;,
				{ method: &#x27;get&#x27;, result: &#x27;success&#x27; },
				null,
				`Signed URL: ${url}`
			);
			return url;
		} catch (error) {
			logger.warn(&#x27;get signed url error&#x27;, error);
			dispatchStorageEvent(
				track,
				&#x27;getSignedUrl&#x27;,
				{ method: &#x27;get&#x27;, result: &#x27;failed&#x27; },
				null,
				`Could not get a signed URL for ${key}`
			);
			throw error;
		}
	}

	/**
	 * Put a file in S3 bucket specified to configure method
	 * @param key - key of the object
	 * @param object - File to be put in Amazon S3 bucket
	 * @param [config] - Optional configuration for the underlying S3 command
	 * @return an instance of AWSS3UploadTask or a promise that resolves to an object with the new object&#x27;s key on
	 * success.
	 */
	public put&lt;T extends S3ProviderPutConfig&gt;(
		key: string,
		object: PutObjectCommandInput[&#x27;Body&#x27;],
		config?: T
	): S3ProviderPutOutput&lt;T&gt; {
		const opt = Object.assign({}, this._config, config);
		const { bucket, track, progressCallback, level, resumable } = opt;
		const {
			contentType,
			contentDisposition,
			contentEncoding,
			cacheControl,
			expires,
			metadata,
			tagging,
			acl,
		} = opt;
		const {
			serverSideEncryption,
			SSECustomerAlgorithm,
			SSECustomerKey,
			SSECustomerKeyMD5,
			SSEKMSKeyId,
		} = opt;
		const type = contentType ? contentType : &#x27;binary/octet-stream&#x27;;

		const params: PutObjectCommandInput = {
			Bucket: bucket,
			Key: key,
			Body: object,
			ContentType: type,
		};
		if (cacheControl) {
			params.CacheControl = cacheControl;
		}
		if (contentDisposition) {
			params.ContentDisposition = contentDisposition;
		}
		if (contentEncoding) {
			params.ContentEncoding = contentEncoding;
		}
		if (expires) {
			params.Expires = expires;
		}
		if (metadata) {
			params.Metadata = metadata;
		}
		if (tagging) {
			params.Tagging = tagging;
		}
		if (serverSideEncryption) {
			params.ServerSideEncryption = serverSideEncryption;
		}
		if (SSECustomerAlgorithm) {
			params.SSECustomerAlgorithm = SSECustomerAlgorithm;
		}
		if (SSECustomerKey) {
			params.SSECustomerKey = SSECustomerKey;
		}
		if (SSECustomerKeyMD5) {
			params.SSECustomerKeyMD5 = SSECustomerKeyMD5;
		}
		if (SSEKMSKeyId) {
			params.SSEKMSKeyId = SSEKMSKeyId;
		}

		const emitter = new events.EventEmitter();
		const uploader = new AWSS3ProviderManagedUpload(params, opt, emitter);

		if (acl) {
			params.ACL = acl;
		}

		if (resumable === true) {
			const s3Client = this._createNewS3Client(opt);
			// we are using aws sdk middleware to inject the prefix to key, this way we don&#x27;t have to call
			// this._ensureCredentials() which allows us to make this function sync so we can return non-Promise like UploadTask
			s3Client.middlewareStack.add(
				createPrefixMiddleware(opt, key),
				prefixMiddlewareOptions
			);
			const addTaskInput: AddTaskInput = {
				bucket,
				key,
				s3Client,
				file: object as Blob,
				emitter,
				accessLevel: level,
				params,
			};
			// explicitly asserting the type here as Typescript could not infer that resumable is of type true
			return this.startResumableUpload(
				addTaskInput,
				config as typeof config &amp; { resumable: true }
			) as S3ProviderPutOutput&lt;T&gt;;
		}

		try {
			if (progressCallback) {
				if (typeof progressCallback === &#x27;function&#x27;) {
					emitter.on(SEND_UPLOAD_PROGRESS_EVENT, progress =&gt; {
						progressCallback(progress);
					});
				} else {
					logger.warn(
						&#x27;progressCallback should be a function, not a &#x27; +
							typeof progressCallback
					);
				}
			}

			return uploader.upload().then(response =&gt; {
				logger.debug(&#x27;upload result&#x27;, response);
				dispatchStorageEvent(
					track,
					&#x27;upload&#x27;,
					{ method: &#x27;put&#x27;, result: &#x27;success&#x27; },
					null,
					`Upload success for ${key}`
				);
				return { key };
			}) as S3ProviderPutOutput&lt;T&gt;;
		} catch (error) {
			logger.warn(&#x27;error uploading&#x27;, error);
			dispatchStorageEvent(
				track,
				&#x27;upload&#x27;,
				{ method: &#x27;put&#x27;, result: &#x27;failed&#x27; },
				null,
				`Error uploading ${key}`
			);
			throw error;
		}
	}

	/**
	 * Remove the object for specified key
	 * @param {string} key - key of the object
	 * @param {S3ProviderRemoveConfig} [config] - Optional configuration for the underlying S3 command
	 * @return {Promise&lt;S3ProviderRemoveOutput&gt;} - Promise resolves upon successful removal of the object
	 */
	public async remove(
		key: string,
		config?: S3ProviderRemoveConfig
	): Promise&lt;S3ProviderRemoveOutput&gt; {
		const credentialsOK = await this._ensureCredentials();
		if (!credentialsOK || !this._isWithCredentials(this._config)) {
			throw new Error(StorageErrorStrings.NO_CREDENTIALS);
		}
		const opt = Object.assign({}, this._config, config);
		const { bucket, track } = opt;

		const prefix = this._prefix(opt);
		const final_key = prefix + key;
		const s3 = this._createNewS3Client(opt);
		logger.debug(&#x27;remove &#x27; + key + &#x27; from &#x27; + final_key);

		const params: DeleteObjectCommandInput = {
			Bucket: bucket,
			Key: final_key,
		};

		const deleteObjectCommand = new DeleteObjectCommand(params);

		try {
			const response = await s3.send(deleteObjectCommand);
			dispatchStorageEvent(
				track,
				&#x27;delete&#x27;,
				{ method: &#x27;remove&#x27;, result: &#x27;success&#x27; },
				null,
				`Deleted ${key} successfully`
			);
			return response;
		} catch (error) {
			dispatchStorageEvent(
				track,
				&#x27;delete&#x27;,
				{ method: &#x27;remove&#x27;, result: &#x27;failed&#x27; },
				null,
				`Deletion of ${key} failed with ${error}`
			);
			throw error;
		}
	}
	private async _list(
		params: ListObjectsV2Request,
		opt: S3ClientOptions,
		prefix: string
	): Promise&lt;S3ProviderListOutputWithToken&gt; {
		const result: S3ProviderListOutputWithToken = {
			contents: [],
			nextToken: &#x27;&#x27;,
		};
		const s3 = this._createNewS3Client(opt);
		const listObjectsV2Command = new ListObjectsV2Command({ ...params });
		const response = await s3.send(listObjectsV2Command);
		if (response &amp;&amp; response.Contents) {
			result.contents = response.Contents.map(item =&gt; {
				return {
					key: item.Key.substr(prefix.length),
					eTag: item.ETag,
					lastModified: item.LastModified,
					size: item.Size,
				};
			});
			result.nextToken = response.NextContinuationToken;
		}
		return result;
	}

	/**
	 * List bucket objects relative to the level and prefix specified
	 * @param {string} path - the path that contains objects
	 * @param {S3ProviderListConfig} [config] - Optional configuration for the underlying S3 command
	 * @return {Promise&lt;S3ProviderListOutput&gt;} - Promise resolves to list of keys, eTags, lastModified and file size for
	 * all objects in path
	 */
	public async list(
		path: string,
		config?: S3ProviderListConfig
	): Promise&lt;S3ProviderListOutput&gt; {
		const credentialsOK = await this._ensureCredentials();
		if (!credentialsOK || !this._isWithCredentials(this._config)) {
			throw new Error(StorageErrorStrings.NO_CREDENTIALS);
		}
		const opt: S3ClientOptions = Object.assign({}, this._config, config);
		const { bucket, track, maxKeys } = opt;
		const prefix = this._prefix(opt);
		const final_path = prefix + path;
		logger.debug(&#x27;list &#x27; + path + &#x27; from &#x27; + final_path);
		try {
			const list: S3ProviderListOutput = [];
			let token: string;
			let listResult: S3ProviderListOutputWithToken;
			const params: ListObjectsV2Request = {
				Bucket: bucket,
				Prefix: final_path,
				MaxKeys: 1000,
			};
			if (maxKeys === &#x27;ALL&#x27;) {
				do {
					params.ContinuationToken = token;
					params.MaxKeys = 1000;
					listResult = await this._list(params, opt, prefix);
					list.push(...listResult.contents);
					if (listResult.nextToken) token = listResult.nextToken;
				} while (listResult.nextToken);
			} else {
				maxKeys &lt; 1000 || typeof maxKeys === &#x27;string&#x27;
					? (params.MaxKeys = maxKeys)
					: (params.MaxKeys = 1000);
				listResult = await this._list(params, opt, prefix);
				list.push(...listResult.contents);
				if (maxKeys &gt; 1000)
					logger.warn(
						&quot;maxkeys can be from 0 - 1000 or &#x27;ALL&#x27;. To list all files you can set maxKeys to &#x27;ALL&#x27;.&quot;
					);
			}
			dispatchStorageEvent(
				track,
				&#x27;list&#x27;,
				{ method: &#x27;list&#x27;, result: &#x27;success&#x27; },
				null,
				`${list.length} items returned from list operation`
			);
			logger.debug(&#x27;list&#x27;, list);
			return list;
		} catch (error) {
			logger.warn(&#x27;list error&#x27;, error);
			dispatchStorageEvent(
				track,
				&#x27;list&#x27;,
				{ method: &#x27;list&#x27;, result: &#x27;failed&#x27; },
				null,
				`Listing items failed: ${error.message}`
			);
			throw error;
		}
	}

	private async _ensureCredentials(): Promise&lt;boolean&gt; {
		try {
			const credentials = await Credentials.get();
			if (!credentials) return false;
			const cred = Credentials.shear(credentials);
			logger.debug(&#x27;set credentials for storage&#x27;, cred);
			this._config.credentials = cred;

			return true;
		} catch (error) {
			logger.warn(&#x27;ensure credentials error&#x27;, error);
			return false;
		}
	}

	private _isWithCredentials(
		config: StorageOptions
	): config is StorageOptions &amp; { credentials: ICredentials } {
		return typeof config === &#x27;object&#x27; &amp;&amp; config.hasOwnProperty(&#x27;credentials&#x27;);
	}

	private _prefix(config: {
		credentials: ICredentials;
		level?: StorageAccessLevel;
		customPrefix?: CustomPrefix;
		identityId?: string;
	}): string {
		const { credentials, level } = config;

		const customPrefix = config.customPrefix || {};
		const identityId = config.identityId || credentials.identityId;
		const privatePath =
			(customPrefix.private !== undefined ? customPrefix.private : &#x27;private/&#x27;) +
			identityId +
			&#x27;/&#x27;;
		const protectedPath =
			(customPrefix.protected !== undefined
				? customPrefix.protected
				: &#x27;protected/&#x27;) +
			identityId +
			&#x27;/&#x27;;
		const publicPath =
			customPrefix.public !== undefined ? customPrefix.public : &#x27;public/&#x27;;

		switch (level) {
			case &#x27;private&#x27;:
				return privatePath;
			case &#x27;protected&#x27;:
				return protectedPath;
			default:
				return publicPath;
		}
	}

	/**
	 * Creates an S3 client with new V3 aws sdk
	 */
	private _createNewS3Client(
		config: {
			region?: string;
			cancelTokenSource?: CancelTokenSource;
			dangerouslyConnectToHttpEndpointForTesting?: boolean;
			useAccelerateEndpoint?: boolean;
		},
		emitter?: events.EventEmitter
	): S3Client {
		const s3client = createS3Client(config, emitter);
		s3client.middlewareStack.add(
			autoAdjustClockskewMiddleware(s3client.config),
			autoAdjustClockskewMiddlewareOptions
		);
		return s3client;
	}
}

/**
 * @deprecated use named import
 */
export default AWSS3Provider;
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:137,&quot;character&quot;:18,&quot;text&quot;:&quot;config&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:138,&quot;character&quot;:36,&quot;text&quot;:&quot;config&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:139,&quot;character&quot;:7,&quot;text&quot;:&quot;config&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:140,&quot;character&quot;:52,&quot;text&quot;:&quot;config&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:163,&quot;character&quot;:41,&quot;text&quot;:&quot;event&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:166,&quot;character&quot;:22,&quot;text&quot;:&quot;event&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:176,&quot;character&quot;:41,&quot;text&quot;:&quot;event&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:189,&quot;character&quot;:31,&quot;text&quot;:&quot;err&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:192,&quot;character&quot;:19,&quot;text&quot;:&quot;err&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:203,&quot;character&quot;:59,&quot;text&quot;:&quot;then&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:204,&quot;character&quot;:4,&quot;text&quot;:&quot;credentials&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:205,&quot;character&quot;:35,&quot;text&quot;:&quot;credentials&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:350,&quot;character&quot;:9,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:339,&quot;character&quot;:11,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:423,&quot;character&quot;:47,&quot;text&quot;:&quot;progress&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:424,&quot;character&quot;:24,&quot;text&quot;:&quot;progress&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:454,&quot;character&quot;:29,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:454,&quot;character&quot;:35,&quot;text&quot;:&quot;message&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:456,&quot;character&quot;:10,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:445,&quot;character&quot;:12,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:478,&quot;character&quot;:39,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:486,&quot;character&quot;:9,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:477,&quot;character&quot;:11,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:598,&quot;character&quot;:44,&quot;text&quot;:&quot;progress&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:599,&quot;character&quot;:23,&quot;text&quot;:&quot;progress&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:621,&quot;character&quot;:34,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:629,&quot;character&quot;:9,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:620,&quot;character&quot;:11,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:678,&quot;character&quot;:38,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:680,&quot;character&quot;:9,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:672,&quot;character&quot;:11,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:767,&quot;character&quot;:29,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:773,&quot;character&quot;:29,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:773,&quot;character&quot;:35,&quot;text&quot;:&quot;message&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:775,&quot;character&quot;:9,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:766,&quot;character&quot;:11,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:781,&quot;character&quot;:9,&quot;text&quot;:&quot;credentials&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:782,&quot;character&quot;:8,&quot;text&quot;:&quot;credentials&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:783,&quot;character&quot;:34,&quot;text&quot;:&quot;credentials&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:789,&quot;character&quot;:43,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/providers/AWSS3Provider.ts&quot;,&quot;line&quot;:788,&quot;character&quot;:11,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Mon, 17 Oct 2022 20:15:23 GMT</p>
    </body>
  </html>
  