
  <!DOCTYPE html>
  <html>
    <head>
      <title>ConnectionStateMonitor.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/utils/ConnectionStateMonitor.ts</td><td class="">100.00%</td><td class="">0%</td><td class="">177</td><td class="">177</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">/*
 * Copyright 2017-2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

import { Reachability } from &#x27;@aws-amplify/core&#x27;;
import Observable, { ZenObservable } from &#x27;zen-observable-ts&#x27;;
import { ConnectionState } from &#x27;../types/PubSub&#x27;;
import { ReachabilityMonitor } from &#x27;./ReachabilityMonitor&#x27;;

// Internal types for tracking different connection states
type LinkedConnectionState = &#x27;connected&#x27; | &#x27;disconnected&#x27;;
type LinkedHealthState = &#x27;healthy&#x27; | &#x27;unhealthy&#x27;;
type LinkedConnectionStates = {
	networkState: LinkedConnectionState;
	connectionState: LinkedConnectionState | &#x27;connecting&#x27;;
	intendedConnectionState: LinkedConnectionState;
	keepAliveState: LinkedHealthState;
};

export const CONNECTION_CHANGE: {
	[key in
		| &#x27;KEEP_ALIVE_MISSED&#x27;
		| &#x27;KEEP_ALIVE&#x27;
		| &#x27;CONNECTION_ESTABLISHED&#x27;
		| &#x27;CONNECTION_FAILED&#x27;
		| &#x27;CLOSING_CONNECTION&#x27;
		| &#x27;OPENING_CONNECTION&#x27;
		| &#x27;CLOSED&#x27;
		| &#x27;ONLINE&#x27;
		| &#x27;OFFLINE&#x27;]: Partial&lt;LinkedConnectionStates&gt;;
} = {
	KEEP_ALIVE_MISSED: { keepAliveState: &#x27;unhealthy&#x27; },
	KEEP_ALIVE: { keepAliveState: &#x27;healthy&#x27; },
	CONNECTION_ESTABLISHED: { connectionState: &#x27;connected&#x27; },
	CONNECTION_FAILED: {
		intendedConnectionState: &#x27;disconnected&#x27;,
		connectionState: &#x27;disconnected&#x27;,
	},
	CLOSING_CONNECTION: { intendedConnectionState: &#x27;disconnected&#x27; },
	OPENING_CONNECTION: {
		intendedConnectionState: &#x27;connected&#x27;,
		connectionState: &#x27;connecting&#x27;,
	},
	CLOSED: { connectionState: &#x27;disconnected&#x27; },
	ONLINE: { networkState: &#x27;connected&#x27; },
	OFFLINE: { networkState: &#x27;disconnected&#x27; },
};

export class ConnectionStateMonitor {
	/**
	 * @private
	 */
	private _linkedConnectionState: LinkedConnectionStates;
	private _linkedConnectionStateObservable: Observable&lt;LinkedConnectionStates&gt;;
	private _linkedConnectionStateObserver: ZenObservable.SubscriptionObserver&lt;LinkedConnectionStates&gt;;
	private _networkMonitoringSubscription?: ZenObservable.Subscription;

	constructor() {
		this._networkMonitoringSubscription = undefined;
		this._linkedConnectionState = {
			networkState: &#x27;connected&#x27;,
			connectionState: &#x27;disconnected&#x27;,
			intendedConnectionState: &#x27;disconnected&#x27;,
			keepAliveState: &#x27;healthy&#x27;,
		};

		this._linkedConnectionStateObservable =
			new Observable&lt;LinkedConnectionStates&gt;(connectionStateObserver =&gt; {
				connectionStateObserver.next(this._linkedConnectionState);
				this._linkedConnectionStateObserver = connectionStateObserver;
			});
	}

	/**
	 * Turn network state monitoring on if it isn&#x27;t on already
	 */
	private enableNetworkMonitoring() {
		// Maintain the network state based on the reachability monitor
		if (this._networkMonitoringSubscription === undefined) {
			this._networkMonitoringSubscription = ReachabilityMonitor().subscribe(
				({ online }) =&gt; {
					this.record(
						online ? CONNECTION_CHANGE.ONLINE : CONNECTION_CHANGE.OFFLINE
					);
				}
			);
		}
	}

	/**
	 * Turn network state monitoring off if it isn&#x27;t off already
	 */
	private disableNetworkMonitoring() {
		this._networkMonitoringSubscription?.unsubscribe();
		this._networkMonitoringSubscription = undefined;
	}

	/**
	 * Get the observable that allows us to monitor the connection state
	 *
	 * @returns {Observable&lt;ConnectionState&gt;} - The observable that emits ConnectionState updates
	 */
	public get connectionStateObservable(): Observable&lt;ConnectionState&gt; {
		let previous: ConnectionState;

		// The linked state aggregates state changes to any of the network, connection,
		// intendedConnection and keepAliveHealth. Some states will change these independent
		// states without changing the overall connection state.

		// After translating from linked states to ConnectionState, then remove any duplicates
		return this._linkedConnectionStateObservable
			.map(value =&gt; {
				return this.connectionStatesTranslator(value);
			})
			.filter(current =&gt; {
				const toInclude = current !== previous;
				previous = current;
				return toInclude;
			});
	}

	/*
	 * Updates local connection state and emits the full state to the observer.
	 */
	record(statusUpdates: Partial&lt;LinkedConnectionStates&gt;) {
		// Maintain the network monitor
		if (statusUpdates.intendedConnectionState === &#x27;connected&#x27;) {
			this.enableNetworkMonitoring();
		} else if (statusUpdates.intendedConnectionState === &#x27;disconnected&#x27;) {
			this.disableNetworkMonitoring();
		}

		// Maintain the socket state
		const newSocketStatus = {
			...this._linkedConnectionState,
			...statusUpdates,
		};

		this._linkedConnectionState = { ...newSocketStatus };

		this._linkedConnectionStateObserver.next(this._linkedConnectionState);
	}

	/*
	 * Translate the ConnectionState structure into a specific ConnectionState string literal union
	 */
	private connectionStatesTranslator({
		connectionState,
		networkState,
		intendedConnectionState,
		keepAliveState,
	}: LinkedConnectionStates): ConnectionState {
		if (connectionState === &#x27;connected&#x27; &amp;&amp; networkState === &#x27;disconnected&#x27;)
			return ConnectionState.ConnectedPendingNetwork;

		if (
			connectionState === &#x27;connected&#x27; &amp;&amp;
			intendedConnectionState === &#x27;disconnected&#x27;
		)
			return ConnectionState.ConnectedPendingDisconnect;

		if (
			connectionState === &#x27;disconnected&#x27; &amp;&amp;
			intendedConnectionState === &#x27;connected&#x27; &amp;&amp;
			networkState === &#x27;disconnected&#x27;
		)
			return ConnectionState.ConnectionDisruptedPendingNetwork;

		if (
			connectionState === &#x27;disconnected&#x27; &amp;&amp;
			intendedConnectionState === &#x27;connected&#x27;
		)
			return ConnectionState.ConnectionDisrupted;

		if (connectionState === &#x27;connected&#x27; &amp;&amp; keepAliveState === &#x27;unhealthy&#x27;)
			return ConnectionState.ConnectedPendingKeepAlive;

		// All remaining states directly correspond to the connection state
		if (connectionState === &#x27;connecting&#x27;) return ConnectionState.Connecting;
		if (connectionState === &#x27;disconnected&#x27;) return ConnectionState.Disconnected;
		return ConnectionState.Connected;
	}
}
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Mon, 17 Oct 2022 20:15:25 GMT</p>
    </body>
  </html>
  