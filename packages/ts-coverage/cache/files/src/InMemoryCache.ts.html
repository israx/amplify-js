
  <!DOCTYPE html>
  <html>
    <head>
      <title>InMemoryCache.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/InMemoryCache.ts</td><td class="">99.48%</td><td class="">0%</td><td class="">386</td><td class="">384</td><td class="">2</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">/*
 * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

import { CacheList, defaultConfig, getCurrTime, CacheObject } from &#x27;./Utils&#x27;;

import { StorageCache } from &#x27;./StorageCache&#x27;;
import { ICache, CacheConfig, CacheItem, CacheItemOptions } from &#x27;./types&#x27;;
import { ConsoleLogger as Logger } from &#x27;@aws-amplify/core&#x27;;

const logger = new Logger(&#x27;InMemoryCache&#x27;);

/**
 * Customized in-memory cache with LRU implemented
 * @member cacheObj - object which store items
 * @member cacheList - list of keys in the cache with LRU
 * @member curSizeInBytes - current size of the cache
 * @member maxPriority - max of the priority
 * @member cacheSizeLimit - the limit of cache size
 */
export class InMemoryCacheClass extends StorageCache implements ICache {
	private cacheList: CacheList[];
	private curSizeInBytes: number;
	private maxPriority: number;
	private cacheSizeLimit: number;

	/**
	 * initialize the cache
	 *
	 * @param config - the configuration of the cache
	 */
	constructor(config?: CacheConfig) {
		const cacheConfig = config
			? Object.assign({}, defaultConfig, config)
			: defaultConfig;
		super(cacheConfig);
		logger.debug(&#x27;now we start!&#x27;);
		this.cacheList = [];
		this.curSizeInBytes = 0;
		this.maxPriority = 5;

		this.getItem = this.getItem.bind(this);
		this.setItem = this.setItem.bind(this);
		this.removeItem = this.removeItem.bind(this);

		// initialize list for every priority
		for (let i = 0; i &lt; this.maxPriority; i += 1) {
			this.cacheList[i] = new CacheList();
		}
	}

	/**
	 * decrease current size of the cache
	 *
	 * @param amount - the amount of the cache size which needs to be decreased
	 */
	private _decreaseCurSizeInBytes(amount: number): void {
		this.curSizeInBytes -= amount;
	}

	/**
	 * increase current size of the cache
	 *
	 * @param amount - the amount of the cache szie which need to be increased
	 */
	private _increaseCurSizeInBytes(amount: number): void {
		this.curSizeInBytes += amount;
	}

	/**
	 * check whether item is expired
	 *
	 * @param key - the key of the item
	 *
	 * @return true if the item is expired.
	 */
	private _isExpired(key: string): boolean {
		const text: string | null = CacheObject.getItem(key);
		const item: CacheItem = JSON.parse(text);
		if (getCurrTime() &gt;= item.expires) {
			return true;
		}
		return false;
	}

	/**
	 * delete item from cache
	 *
	 * @param prefixedKey - the key of the item
	 * @param listIdx - indicates which cache list the key belongs to
	 */
	private _removeItem(prefixedKey: string, listIdx: number): void {
		// delete the key from the list
		this.cacheList[listIdx].removeItem(prefixedKey);
		// decrease the current size of the cache
		this._decreaseCurSizeInBytes(
			JSON.parse(CacheObject.getItem(prefixedKey)).byteSize
		);
		// finally remove the item from memory
		CacheObject.removeItem(prefixedKey);
	}

	/**
	 * put item into cache
	 *
	 * @param prefixedKey - the key of the item
	 * @param itemData - the value of the item
	 * @param itemSizeInBytes - the byte size of the item
	 * @param listIdx - indicates which cache list the key belongs to
	 */
	private _setItem(
		prefixedKey: string,
		item: CacheItem,
		listIdx: number
	): void {
		// insert the key into the list
		this.cacheList[listIdx].insertItem(prefixedKey);
		// increase the current size of the cache
		this._increaseCurSizeInBytes(item.byteSize);
		// finally add the item into memory
		CacheObject.setItem(prefixedKey, JSON.stringify(item));
	}

	/**
	 * see whether cache is full
	 *
	 * @param itemSize
	 *
	 * @return true if cache is full
	 */
	private _isCacheFull(itemSize: number): boolean {
		return this.curSizeInBytes + itemSize &gt; this.config.capacityInBytes;
	}

	/**
	 * check whether the cache contains the key
	 *
	 * @param key
	 */
	private containsKey(key: string): number {
		const prefixedKey: string = this.config.keyPrefix + key;
		for (let i = 0; i &lt; this.maxPriority; i += 1) {
			if (this.cacheList[i].containsKey(prefixedKey)) {
				return i + 1;
			}
		}
		return -1;
	}

	/**
	 * * Set item into cache. You can put number, string, boolean or object.
	 * The cache will first check whether has the same key.
	 * If it has, it will delete the old item and then put the new item in
	 * The cache will pop out items if it is full
	 * You can specify the cache item options. The cache will abort and output a warning:
	 * If the key is invalid
	 * If the size of the item exceeds itemMaxSize.
	 * If the value is undefined
	 * If incorrect cache item configuration
	 * If error happened with browser storage
	 *
	 * @param key - the key of the item
	 * @param value - the value of the item
	 * @param options - optional, the specified meta-data
	 *
	 * @throws if the item is too big which exceeds the limit of single item size
	 * @throws if the key is invalid
	 */
	public setItem(
		key: string,
		value: object | string | number | boolean,
		options?: CacheItemOptions
	): void {
		const prefixedKey: string = this.config.keyPrefix + key;
		// invalid keys
		if (
			prefixedKey === this.config.keyPrefix ||
			prefixedKey === this.cacheCurSizeKey
		) {
			logger.warn(`Invalid key: should not be empty or &#x27;CurSize&#x27;`);
			return;
		}

		if (typeof value === &#x27;undefined&#x27;) {
			logger.warn(`The value of item should not be undefined!`);
			return;
		}

		const cacheItemOptions: CacheItemOptions = {
			priority:
				options &amp;&amp; options.priority !== undefined
					? options.priority
					: this.config.defaultPriority,
			expires:
				options &amp;&amp; options.expires !== undefined
					? options.expires
					: this.config.defaultTTL + getCurrTime(),
		};

		if (cacheItemOptions.priority &lt; 1 || cacheItemOptions.priority &gt; 5) {
			logger.warn(
				`Invalid parameter: priority due to out or range. It should be within 1 and 5.`
			);
			return;
		}

		const item: CacheItem = this.fillCacheItem(
			prefixedKey,
			value,
			cacheItemOptions
		);

		// check wether this item is too big;
		if (item.byteSize &gt; this.config.itemMaxSize) {
			logger.warn(
				`Item with key: ${key} you are trying to put into is too big!`
			);
			return;
		}

		// if key already in the cache, then delete it.
		const presentKeyPrio: number = this.containsKey(key);
		if (presentKeyPrio !== -1) {
			this._removeItem(prefixedKey, presentKeyPrio - 1);
		}

		// pop out items in the cache when cache is full based on LRU
		// first start from lowest priority cache list
		let cacheListIdx = this.maxPriority - 1;
		while (this._isCacheFull(item.byteSize) &amp;&amp; cacheListIdx &gt;= 0) {
			if (!this.cacheList[cacheListIdx].isEmpty()) {
				const popedItemKey = this.cacheList[cacheListIdx].getLastItem();
				this._removeItem(popedItemKey, cacheListIdx);
			} else {
				cacheListIdx -= 1;
			}
		}

		this._setItem(prefixedKey, item, Number(item.priority) - 1);
	}

	/**
	 * Get item from cache. It will return null if item doesnâ€™t exist or it has been expired.
	 * If you specified callback function in the options,
	 * then the function will be executed if no such item in the cache
	 * and finally put the return value into cache.
	 * Please make sure the callback function will return the value you want to put into the cache.
	 * The cache will abort output a warning:
	 * If the key is invalid
	 *
	 * @param key - the key of the item
	 * @param options - the options of callback function
	 */
	public getItem(key: string, options?: CacheItemOptions): any {
		let ret: string | null = null;
		const prefixedKey: string = this.config.keyPrefix + key;

		if (
			prefixedKey === this.config.keyPrefix ||
			prefixedKey === this.cacheCurSizeKey
		) {
			logger.warn(`Invalid key: should not be empty or &#x27;CurSize&#x27;`);
			return null;
		}

		// check whether it&#x27;s in the cachelist
		const presentKeyPrio: number = this.containsKey(key);
		if (presentKeyPrio !== -1) {
			if (this._isExpired(prefixedKey)) {
				// if expired, remove that item and return null
				this._removeItem(prefixedKey, presentKeyPrio - 1);
			} else {
				// if not expired, great, return the value and refresh it
				ret = CacheObject.getItem(prefixedKey);
				const item: CacheItem = JSON.parse(ret);
				this.cacheList[item.priority - 1].refresh(prefixedKey);
				return item.data;
			}
		}

		if (options &amp;&amp; options.callback !== undefined) {
			const val: object | string | number | boolean = options.callback();
			if (val !== null) {
				this.setItem(key, val, options);
			}
			return val;
		}
		return null;
	}

	/**
	 * remove item from the cache
	 *
	 * @param key - the key of the item
	 */
	public removeItem(key: string): void {
		const prefixedKey: string = this.config.keyPrefix + key;

		// check if the key is in the cache
		const presentKeyPrio: number = this.containsKey(key);
		if (presentKeyPrio !== -1) {
			this._removeItem(prefixedKey, presentKeyPrio - 1);
		}
	}

	/**
	 * clear the entire cache
	 */
	public clear(): void {
		for (let i = 0; i &lt; this.maxPriority; i += 1) {
			for (const key of this.cacheList[i].getKeys()) {
				this._removeItem(key, i);
			}
		}
	}

	/**
	 * Return all the keys in the cache.
	 */
	public getAllKeys(): string[] {
		const keys: string[] = [];
		for (let i = 0; i &lt; this.maxPriority; i += 1) {
			for (const key of this.cacheList[i].getKeys()) {
				keys.push(key.substring(this.config.keyPrefix.length));
			}
		}

		return keys;
	}

	/**
	 * return the current size of the cache
	 *
	 * @return the current size of the cache
	 */
	public getCacheCurSize(): number {
		return this.curSizeInBytes;
	}

	/**
	 * Return a new instance of cache with customized configuration.
	 * @param config - the customized configuration
	 */
	public createInstance(config: CacheConfig): ICache {
		return new InMemoryCacheClass(config);
	}
}

export const InMemoryCache: ICache = new InMemoryCacheClass();
/**
 * @deprecated use named import
 */
export default InMemoryCache;
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;src/InMemoryCache.ts&quot;,&quot;line&quot;:105,&quot;character&quot;:48,&quot;text&quot;:&quot;byteSize&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/InMemoryCache.ts&quot;,&quot;line&quot;:285,&quot;character&quot;:16,&quot;text&quot;:&quot;data&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Mon, 17 Oct 2022 20:15:22 GMT</p>
    </body>
  </html>
  